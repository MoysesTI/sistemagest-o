[
  {
    "projectId": "9c49b194-e156-4fdf-9508-b5d4b1b9511f",
    "testId": "9819b4a0-32cf-4c1d-9902-af5b1f9a8fc5",
    "userId": "e408f458-7011-70d8-02e7-eee4728b30a5",
    "title": "TC001-user login functionality",
    "description": "Test the user login endpoint to verify successful authentication with valid credentials and proper error handling with invalid credentials.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5001\"\nLOGIN_ENDPOINT = \"/api/auth/login\"\nTIMEOUT = 30\n\ndef test_user_login_functionality():\n    headers = {\"Content-Type\": \"application/json\"}\n\n    # Valid credentials test\n    valid_payload = {\n        \"email\": \"admin@prismatech.com\",\n        \"senha\": \"admin123\"\n    }\n    try:\n        response = requests.post(\n            BASE_URL + LOGIN_ENDPOINT,\n            json=valid_payload,\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert response.status_code == 200, f\"Expected 200 OK, got {response.status_code}\"\n        data = response.json()\n        assert \"token\" in data and isinstance(data[\"token\"], str) and data[\"token\"], \"Token missing or empty in response\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed for valid credentials: {e}\"\n\n    # Invalid credentials test\n    invalid_payload = {\n        \"email\": \"admin@prismatech.com\",\n        \"senha\": \"wrongpassword\"\n    }\n    try:\n        response = requests.post(\n            BASE_URL + LOGIN_ENDPOINT,\n            json=invalid_payload,\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        # Expect unauthorized or appropriate error status code\n        assert response.status_code in (400, 401), f\"Expected 400 or 401, got {response.status_code}\"\n        data = response.json()\n        # Assuming error message or indication in response\n        assert (\"error\" in data or \"message\" in data), \"Error message missing in invalid login response\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed for invalid credentials: {e}\"\n\ntest_user_login_functionality()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-05T13:53:48.031Z",
    "modified": "2026-02-05T13:54:14.454Z"
  },
  {
    "projectId": "9c49b194-e156-4fdf-9508-b5d4b1b9511f",
    "testId": "0b6efaef-d873-4201-a2aa-27a614577ec6",
    "userId": "e408f458-7011-70d8-02e7-eee4728b30a5",
    "title": "TC002-user registration process",
    "description": "Validate the user registration endpoint to ensure new users can register successfully and duplicate or invalid data is handled correctly.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:5001\"\nREGISTER_URL = f\"{BASE_URL}/api/auth/register\"\nLOGIN_URL = f\"{BASE_URL}/api/auth/login\"\n\ndef test_user_registration_process():\n    headers = {\"Content-Type\": \"application/json\"}\n    timeout = 30\n\n    # Generate a unique email to avoid duplicates in seeded DB\n    unique_email = f\"testuser+{uuid.uuid4()}@prismatech.com\"\n    password = \"TestPassword123!\"\n    user_data = {\n        \"email\": unique_email,\n        \"senha\": password\n    }\n\n    # 1. Successful Registration\n    try:\n        resp = requests.post(REGISTER_URL, json=user_data, headers=headers, timeout=timeout)\n        assert resp.status_code == 201 or resp.status_code == 200, f\"Expected 200 or 201 but got {resp.status_code}\"\n        resp_json = resp.json()\n        # Must have some user registration confirmation, e.g., user id or success message\n        assert \"email\" in resp_json or \"id\" in resp_json or \"message\" in resp_json\n\n        # 2. Try to register the same user again (duplicate)\n        resp_duplicate = requests.post(REGISTER_URL, json=user_data, headers=headers, timeout=timeout)\n        # Expect error status code for duplicate, likely 400 or 409\n        assert resp_duplicate.status_code in (400,409)\n\n        # 3. Register with invalid data - missing email\n        invalid_data_1 = {\"senha\": \"somepassword\"}\n        resp_invalid_1 = requests.post(REGISTER_URL, json=invalid_data_1, headers=headers, timeout=timeout)\n        assert resp_invalid_1.status_code == 400\n\n        # 4. Register with invalid data - missing senha (password)\n        invalid_data_2 = {\"email\": f\"invalid+{uuid.uuid4()}@prismatech.com\"}\n        resp_invalid_2 = requests.post(REGISTER_URL, json=invalid_data_2, headers=headers, timeout=timeout)\n        assert resp_invalid_2.status_code == 400\n\n        # 5. Register with invalid data - invalid email format\n        invalid_data_3 = {\"email\": \"not-an-email\", \"senha\": \"password123\"}\n        resp_invalid_3 = requests.post(REGISTER_URL, json=invalid_data_3, headers=headers, timeout=timeout)\n        # Assuming system validates email format and returns 400\n        assert resp_invalid_3.status_code == 400\n\n        # 6. Validate newly registered user can login with correct credentials\n        login_data = {\"email\": unique_email, \"senha\": password}\n        resp_login = requests.post(LOGIN_URL, json=login_data, headers=headers, timeout=timeout)\n        assert resp_login.status_code == 200\n        login_json = resp_login.json()\n        assert \"token\" in login_json and isinstance(login_json[\"token\"], str) and len(login_json[\"token\"]) > 0\n\n        # 7. Validate login fails for wrong password\n        login_wrong_pass = {\"email\": unique_email, \"senha\": \"WrongPassword\"}\n        resp_login_fail = requests.post(LOGIN_URL, json=login_wrong_pass, headers=headers, timeout=timeout)\n        assert resp_login_fail.status_code == 401 or resp_login_fail.status_code == 400\n\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_user_registration_process()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 64, in <module>\n  File \"<string>\", line 23, in test_user_registration_process\nAssertionError: Expected 200 or 201 but got 500\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-05T13:53:48.038Z",
    "modified": "2026-02-05T13:54:28.531Z"
  },
  {
    "projectId": "9c49b194-e156-4fdf-9508-b5d4b1b9511f",
    "testId": "de30f2d3-39bb-4d5c-add8-51efad439f3f",
    "userId": "e408f458-7011-70d8-02e7-eee4728b30a5",
    "title": "TC003-retrieve logged in user data",
    "description": "Check the endpoint for retrieving logged-in user data to confirm it returns accurate user information when authenticated and denies access when not.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5001\"\nLOGIN_ENDPOINT = \"/api/auth/login\"\nME_ENDPOINT = \"/api/auth/me\"\nTIMEOUT = 30\n\ndef test_retrieve_logged_in_user_data():\n    login_url = BASE_URL + LOGIN_ENDPOINT\n    me_url = BASE_URL + ME_ENDPOINT\n    \n    credentials = {\n        \"email\": \"admin@prismatech.com\",\n        \"senha\": \"admin123\"\n    }\n    \n    # Authenticate and get token\n    try:\n        login_resp = requests.post(login_url, json=credentials, timeout=TIMEOUT)\n        assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}\"\n        login_data = login_resp.json()\n        token = login_data.get(\"token\")\n        assert token, \"Token not found in login response\"\n    except Exception as e:\n        raise AssertionError(f\"Login request failed: {e}\")\n    \n    headers_auth = {\"Authorization\": f\"Bearer {token}\"}\n    \n    # Retrieve user data with authentication\n    try:\n        me_resp = requests.get(me_url, headers=headers_auth, timeout=TIMEOUT)\n        assert me_resp.status_code == 200, f\"Authenticated user data request failed with status {me_resp.status_code}\"\n        user_data = me_resp.json()\n        assert isinstance(user_data, dict), \"User data response is not a JSON object\"\n        # Confirm expected fields present in user data\n        expected_keys = [\"id\", \"nome\"]\n        for key in expected_keys:\n            assert key in user_data, f\"Expected key '{key}' not found in user data\"\n        if \"email\" in user_data:\n            assert user_data[\"email\"].lower() == credentials[\"email\"].lower(), \"Returned user email does not match logged in email\"\n    except Exception as e:\n        raise AssertionError(f\"Fetching authenticated user data failed: {e}\")\n    \n    # Attempt to access user data without authentication\n    try:\n        me_resp_no_auth = requests.get(me_url, timeout=TIMEOUT)\n        assert me_resp_no_auth.status_code in (401, 403), f\"Unauthorized access did not return 401 or 403 but {me_resp_no_auth.status_code}\"\n    except Exception as e:\n        raise AssertionError(f\"Request without authentication failed unexpectedly: {e}\")\n\ntest_retrieve_logged_in_user_data()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 38, in test_retrieve_logged_in_user_data\nAssertionError: Expected key 'id' not found in user data\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 51, in <module>\n  File \"<string>\", line 42, in test_retrieve_logged_in_user_data\nAssertionError: Fetching authenticated user data failed: Expected key 'id' not found in user data\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-05T13:53:48.043Z",
    "modified": "2026-02-05T13:54:52.990Z"
  },
  {
    "projectId": "9c49b194-e156-4fdf-9508-b5d4b1b9511f",
    "testId": "7d7626e8-4129-4720-a5a6-5e91405e3b32",
    "userId": "e408f458-7011-70d8-02e7-eee4728b30a5",
    "title": "TC004-list schedule entries",
    "description": "Test the schedule listing endpoint to ensure it returns the correct schedule data for authenticated users.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5001\"\nLOGIN_ENDPOINT = \"/api/auth/login\"\nSCHEDULE_ENDPOINT = \"/api/cronograma\"\nAUTH_EMAIL = \"admin@prismatech.com\"\nAUTH_PASSWORD = \"admin123\"\nTIMEOUT = 30\n\ndef test_list_schedule_entries():\n    # Login to get the token\n    login_payload = {\n        \"email\": AUTH_EMAIL,\n        \"senha\": AUTH_PASSWORD\n    }\n    try:\n        login_response = requests.post(\n            BASE_URL + LOGIN_ENDPOINT,\n            json=login_payload,\n            timeout=TIMEOUT\n        )\n        assert login_response.status_code == 200, f\"Login failed: {login_response.text}\"\n        login_data = login_response.json()\n        assert \"token\" in login_data, \"No token found in login response\"\n        token = login_data[\"token\"]\n\n        # Use token to get schedule listing\n        headers = {\n            \"Authorization\": f\"Bearer {token}\"\n        }\n        schedule_response = requests.get(\n            BASE_URL + SCHEDULE_ENDPOINT,\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert schedule_response.status_code == 200, f\"Schedule listing failed: {schedule_response.text}\"\n        schedule_data = schedule_response.json()\n        # Validate schedule data structure - expecting a list or dict with schedule info\n        assert isinstance(schedule_data, (list, dict)), \"Schedule data is not a list or dict\"\n\n    except requests.RequestException as e:\n        assert False, f\"HTTP request failed: {e}\"\n\ntest_list_schedule_entries()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-05T13:53:48.049Z",
    "modified": "2026-02-05T13:54:33.564Z"
  },
  {
    "projectId": "9c49b194-e156-4fdf-9508-b5d4b1b9511f",
    "testId": "2f0e3a5a-c9ba-43d4-869f-95219110c91e",
    "userId": "e408f458-7011-70d8-02e7-eee4728b30a5",
    "title": "TC005-import class schedules",
    "description": "Verify the schedule import endpoint to confirm that class schedules can be imported correctly and handle invalid import data gracefully.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5001\"\nLOGIN_URL = f\"{BASE_URL}/api/auth/login\"\nIMPORT_SCHEDULE_URL = f\"{BASE_URL}/api/cronograma/importar\"\nTIMEOUT = 30\n\ndef test_import_class_schedules():\n    # Login to get JWT token\n    login_payload = {\n        \"email\": \"admin@prismatech.com\",\n        \"senha\": \"admin123\"\n    }\n    login_resp = requests.post(LOGIN_URL, json=login_payload, timeout=TIMEOUT)\n    assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}\"\n    token = login_resp.json().get(\"token\")\n    assert token, \"Authentication token not found in login response\"\n\n    headers = {\n        \"Authorization\": f\"Bearer {token}\"\n    }\n\n    # Valid schedule import data example\n    valid_import_payload = [\n        {\n            \"turmaId\": 1,\n            \"cursoId\": 1,\n            \"moduloId\": 1,\n            \"data\": \"2026-03-01\",\n            \"horaInicio\": \"09:00\",\n            \"horaFim\": \"10:30\",\n            \"descricao\": \"Aula de introdução\"\n        },\n        {\n            \"turmaId\": 1,\n            \"cursoId\": 1,\n            \"moduloId\": 2,\n            \"data\": \"2026-03-02\",\n            \"horaInicio\": \"11:00\",\n            \"horaFim\": \"12:30\",\n            \"descricao\": \"Aula avançada\"\n        }\n    ]\n\n    # Import valid schedule data\n    valid_resp = requests.post(IMPORT_SCHEDULE_URL, json=valid_import_payload, headers=headers, timeout=TIMEOUT)\n    assert valid_resp.status_code == 201 or valid_resp.status_code == 200, f\"Valid import failed with status {valid_resp.status_code}\"\n    valid_result = valid_resp.json()\n    assert isinstance(valid_result, dict) or isinstance(valid_result, list), \"Response JSON format invalid for valid import\"\n\n    # Invalid schedule import data examples\n    invalid_payloads = [\n        [],  # Empty list, probably valid or accepted\n        [{}],  # Empty object in list\n        [{\"turmaId\": \"invalid\", \"cursoId\": 1}],  # Wrong data type for turmaId\n        [{\"data\": \"2026-02-30\", \"horaInicio\": \"09:00\"}],  # Invalid date\n        \"not a json array\",  # Completely wrong type of payload\n        None  # None payload\n    ]\n\n    for invalid_data in invalid_payloads:\n        try:\n            if invalid_data is None:\n                resp = requests.post(IMPORT_SCHEDULE_URL, headers=headers, timeout=TIMEOUT)\n            else:\n                resp = requests.post(IMPORT_SCHEDULE_URL, json=invalid_data, headers=headers, timeout=TIMEOUT)\n        except requests.exceptions.RequestException as e:\n            # If server closes connection or error, consider that acceptable error handling\n            continue\n        # For empty list accept success (200 or 201), for others expect client error\n        if invalid_data == []:\n            assert resp.status_code == 200 or resp.status_code == 201, f\"Empty list payload did not produce success, got {resp.status_code}\"\n        else:\n            assert resp.status_code >= 400 and resp.status_code < 500, \\\n                f\"Invalid payload did not produce client error, got status {resp.status_code} for data {invalid_data}\"\n\ntest_import_class_schedules()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 77, in <module>\n  File \"<string>\", line 74, in test_import_class_schedules\nAssertionError: Invalid payload did not produce client error, got status 200 for data [{}]\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-05T13:53:48.054Z",
    "modified": "2026-02-05T13:54:54.644Z"
  },
  {
    "projectId": "9c49b194-e156-4fdf-9508-b5d4b1b9511f",
    "testId": "4a9d58bb-20e8-49e5-8a69-cffa0707a2bc",
    "userId": "e408f458-7011-70d8-02e7-eee4728b30a5",
    "title": "TC006-mark lesson or task as completed",
    "description": "Test the endpoint for marking a lesson or task as completed to ensure the status updates correctly and invalid IDs are handled.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5001\"\nLOGIN_URL = f\"{BASE_URL}/api/auth/login\"\nCRONOGRAMA_URL = f\"{BASE_URL}/api/cronograma\"\nTAREFAS_EXTRAS_URL = f\"{BASE_URL}/api/tarefas-extras\"\nTIMEOUT = 30\n\nadmin_email = \"admin@prismatech.com\"\nadmin_password = \"admin123\"\n\ndef test_TC006_mark_lesson_or_task_as_completed():\n    # Authenticate and get token\n    login_payload = {\"email\": admin_email, \"senha\": admin_password}\n    login_resp = requests.post(LOGIN_URL, json=login_payload, timeout=TIMEOUT)\n    assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}\"\n    token = login_resp.json().get(\"token\")\n    assert token, \"No token received for admin user\"\n\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n\n    # Helper function to cleanup extra task\n    def delete_extra_task(task_id):\n        try:\n            delete_resp = requests.delete(f\"{TAREFAS_EXTRAS_URL}/{task_id}\", headers=headers, timeout=TIMEOUT)\n            # It's okay if deletion fails (maybe task already deleted)\n        except Exception:\n            pass\n\n    # Step 1: Try to mark an existing cronograma lesson/task as completed\n    # List cronograma to get an existing lesson/task id\n    cronograma_list_resp = requests.get(CRONOGRAMA_URL, headers=headers, timeout=TIMEOUT)\n    assert cronograma_list_resp.status_code == 200\n    cronograma = cronograma_list_resp.json()\n    assert isinstance(cronograma, list)\n\n    lesson_or_task_id = None\n    if cronograma:\n        lesson_or_task_id = cronograma[0].get(\"id\")\n    # If no lessons exist, we cannot create one via exposed API per PRD, so skip to extra task\n\n    # Test marking valid cronograma id as completed\n    if lesson_or_task_id is not None:\n        mark_url = f\"{CRONOGRAMA_URL}/{lesson_or_task_id}/check\"\n        mark_resp = requests.put(mark_url, headers=headers, timeout=TIMEOUT)\n        assert mark_resp.status_code == 200, f\"Failed to mark lesson/task as completed, status {mark_resp.status_code}\"\n        mark_resp_json = mark_resp.json()\n        assert (\n            mark_resp_json.get(\"completed\") is True\n            or mark_resp_json.get(\"status\") == \"completed\"\n            or mark_resp_json.get(\"checked\") is True\n        )\n\n    # Step 2: Create a new extra task and mark it as completed\n    new_task_payload = {\n        \"titulo\": \"Test task TC006 marking complete\",\n        \"descricao\": \"Temporary task to test marking complete\",\n        \"dataPrevista\": \"2026-12-31\"  # Added required date field\n    }\n    create_task_resp = requests.post(TAREFAS_EXTRAS_URL, headers=headers, json=new_task_payload, timeout=TIMEOUT)\n    assert create_task_resp.status_code == 201, f\"Failed to create extra task, status {create_task_resp.status_code}\"\n    task_data = create_task_resp.json()\n    task_id = task_data.get(\"id\")\n    assert task_id, \"No task ID returned on creation\"\n\n    try:\n        mark_task_url = f\"{TAREFAS_EXTRAS_URL}/{task_id}/concluir\"\n        mark_task_resp = requests.put(mark_task_url, headers=headers, timeout=TIMEOUT)\n        assert mark_task_resp.status_code == 200, f\"Failed to mark extra task as completed, status {mark_task_resp.status_code}\"\n        mark_task_json = mark_task_resp.json()\n        # Assuming API marks a field like \"concluida\"\n        assert mark_task_json.get(\"concluida\") is True\n    finally:\n        delete_extra_task(task_id)\n\n    # Step 3: Test invalid IDs for both endpoints\n    invalid_id = \"00000000-0000-0000-0000-000000000000\"\n\n    if lesson_or_task_id is not None:\n        invalid_mark_resp = requests.put(f\"{CRONOGRAMA_URL}/{invalid_id}/check\", headers=headers, timeout=TIMEOUT)\n        assert invalid_mark_resp.status_code in (400, 404), f\"Invalid ID for lesson/task did not return expected error, got {invalid_mark_resp.status_code}\"\n    \n    invalid_mark_task_resp = requests.put(f\"{TAREFAS_EXTRAS_URL}/{invalid_id}/concluir\", headers=headers, timeout=TIMEOUT)\n    assert invalid_mark_task_resp.status_code in (400, 404), f\"Invalid ID for extra task did not return expected error, got {invalid_mark_task_resp.status_code}\"\n\ntest_TC006_mark_lesson_or_task_as_completed()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 86, in <module>\n  File \"<string>\", line 61, in test_TC006_mark_lesson_or_task_as_completed\nAssertionError: Failed to create extra task, status 500\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-05T13:53:48.060Z",
    "modified": "2026-02-05T13:55:11.193Z"
  },
  {
    "projectId": "9c49b194-e156-4fdf-9508-b5d4b1b9511f",
    "testId": "d2ee4140-8138-4c90-affd-8d23300b5a34",
    "userId": "e408f458-7011-70d8-02e7-eee4728b30a5",
    "title": "TC007-register taught content for lesson",
    "description": "Validate the endpoint for registering content taught in a lesson to ensure content is recorded properly and errors are managed.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5001\"\nLOGIN_URL = f\"{BASE_URL}/api/auth/login\"\nSCHEDULE_URL = f\"{BASE_URL}/api/cronograma\"\n\nADMIN_EMAIL = \"admin@prismatech.com\"\nADMIN_PASSWORD = \"admin123\"\nTIMEOUT = 30\n\ndef test_register_taught_content_for_lesson():\n    # Authenticate as admin to get JWT token\n    login_payload = {\"email\": ADMIN_EMAIL, \"senha\": ADMIN_PASSWORD}\n    try:\n        login_resp = requests.post(LOGIN_URL, json=login_payload, timeout=TIMEOUT)\n        login_resp.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Login request failed: {e}\"\n    login_data = login_resp.json()\n    assert \"token\" in login_data and isinstance(login_data[\"token\"], str), \"Login response missing token\"\n    token = login_data[\"token\"]\n    headers = {\"Authorization\": f\"Bearer {token}\", \"Content-Type\": \"application/json\"}\n\n    # Get existing schedule lessons to find a valid ID\n    try:\n        schedule_resp = requests.get(SCHEDULE_URL, headers=headers, timeout=TIMEOUT)\n        schedule_resp.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Failed to list schedule: {e}\"\n\n    schedule_list = schedule_resp.json()\n    assert isinstance(schedule_list, list) and len(schedule_list) > 0, \"Schedule list is empty or invalid\"\n\n    lesson = schedule_list[0]\n    lesson_id = lesson.get(\"id\")\n    assert lesson_id is not None, \"Lesson ID not found in schedule data\"\n\n    content_registration_url = f\"{SCHEDULE_URL}/{lesson_id}/conteudo\"\n\n    # Prepare valid content payload for registering taught content\n    valid_content = {\n        \"conteudo\": \"Introduced unit testing and API integration concepts.\"\n    }\n\n    # Test successful registration of taught content\n    try:\n        put_resp = requests.put(content_registration_url, json=valid_content, headers=headers, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"PUT request to register content failed: {e}\"\n    assert put_resp.status_code == 200, f\"Expected 200 OK, got {put_resp.status_code}\"\n    put_data = put_resp.json()\n    assert \"message\" in put_data and (\"success\" in put_data[\"message\"].lower() or \"registered\" in put_data[\"message\"].lower()), \"Success message not found in response\"\n\n    # Test error case: missing 'conteudo' field\n    invalid_content = {}\n\n    try:\n        error_resp = requests.put(content_registration_url, json=invalid_content, headers=headers, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"PUT request with invalid payload failed: {e}\"\n    assert error_resp.status_code >= 400, f\"Expected error status for invalid payload, got {error_resp.status_code}\"\n    error_data = error_resp.json()\n    assert \"error\" in error_data or \"message\" in error_data, \"Error message not found for invalid payload\"\n\ntest_register_taught_content_for_lesson()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 65, in <module>\n  File \"<string>\", line 32, in test_register_taught_content_for_lesson\nAssertionError: Schedule list is empty or invalid\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-05T13:53:48.065Z",
    "modified": "2026-02-05T13:54:26.856Z"
  },
  {
    "projectId": "9c49b194-e156-4fdf-9508-b5d4b1b9511f",
    "testId": "cffc3ecf-8dde-477e-8daa-bfbe175a3453",
    "userId": "e408f458-7011-70d8-02e7-eee4728b30a5",
    "title": "TC008-manage class groups",
    "description": "Test the class groups API endpoints for creating, listing, updating, and deleting class groups to verify full CRUD functionality.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:5001\"\nLOGIN_URL = f\"{BASE_URL}/api/auth/login\"\nTURMAS_URL = f\"{BASE_URL}/api/turmas\"\nTIMEOUT = 30\n\ndef test_manage_class_groups():\n    # Authenticate and get JWT token\n    auth_payload = {\"email\": \"admin@prismatech.com\", \"senha\": \"admin123\"}\n    auth_response = requests.post(LOGIN_URL, json=auth_payload, timeout=TIMEOUT)\n    assert auth_response.status_code == 200, f\"Login failed: {auth_response.text}\"\n    token = auth_response.json().get(\"token\")\n    assert token, \"Token not found in login response\"\n\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n\n    # Step 1: Create a new class group (turma)\n    unique_name = f\"TestClassGroup_{uuid.uuid4()}\"\n    create_payload = {\"nome\": unique_name}\n    create_response = requests.post(TURMAS_URL, json=create_payload, headers=headers, timeout=TIMEOUT)\n    assert create_response.status_code == 201, f\"Failed to create turma: {create_response.text}\"\n    turma = create_response.json()\n    turma_id = turma.get(\"id\")\n    assert turma_id, \"Created turma has no id\"\n\n    try:\n        # Step 2: List all class groups and verify the created turma is listed\n        list_response = requests.get(TURMAS_URL, headers=headers, timeout=TIMEOUT)\n        assert list_response.status_code == 200, f\"Failed to list turmas: {list_response.text}\"\n        turmas_list = list_response.json()\n        assert any(t.get(\"id\") == turma_id for t in turmas_list), \"Created turma not found in list\"\n\n        # Step 3: Update the created class group\n        updated_name = unique_name + \"_Updated\"\n        update_payload = {\"nome\": updated_name}\n        update_response = requests.put(f\"{TURMAS_URL}/{turma_id}\", json=update_payload, headers=headers, timeout=TIMEOUT)\n        assert update_response.status_code == 200, f\"Failed to update turma: {update_response.text}\"\n        updated_turma = update_response.json()\n        assert updated_turma.get(\"nome\") == updated_name, \"Turma name not updated correctly\"\n\n        # Step 4: Delete the created class group\n        delete_response = requests.delete(f\"{TURMAS_URL}/{turma_id}\", headers=headers, timeout=TIMEOUT)\n        assert delete_response.status_code == 204, f\"Failed to delete turma: {delete_response.text}\"\n\n        # Verify deletion by listing again\n        list_after_delete_response = requests.get(TURMAS_URL, headers=headers, timeout=TIMEOUT)\n        assert list_after_delete_response.status_code == 200, f\"Failed to list turmas after delete: {list_after_delete_response.text}\"\n        turmas_after_delete = list_after_delete_response.json()\n        assert all(t.get(\"id\") != turma_id for t in turmas_after_delete), \"Deleted turma still present in list\"\n\n    except AssertionError:\n        # On assertion error attempt to cleanup resource\n        try:\n            requests.delete(f\"{TURMAS_URL}/{turma_id}\", headers=headers, timeout=TIMEOUT)\n        except Exception:\n            pass\n        raise\n\ntest_manage_class_groups()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 61, in <module>\n  File \"<string>\", line 23, in test_manage_class_groups\nAssertionError: Failed to create turma: {\"error\":\"Erro interno do servidor\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-05T13:53:48.071Z",
    "modified": "2026-02-05T13:54:54.645Z"
  },
  {
    "projectId": "9c49b194-e156-4fdf-9508-b5d4b1b9511f",
    "testId": "04c896b1-fdc3-4634-af18-5e04e8db7bd0",
    "userId": "e408f458-7011-70d8-02e7-eee4728b30a5",
    "title": "TC009-manage courses and modules",
    "description": "Verify the courses API endpoints for listing courses, creating new courses, and adding modules to courses to ensure proper course management.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:5001\"\nLOGIN_URL = f\"{BASE_URL}/api/auth/login\"\nCOURSES_URL = f\"{BASE_URL}/api/cursos\"\n\nADMIN_EMAIL = \"admin@prismatech.com\"\nADMIN_PASSWORD = \"admin123\"\nTIMEOUT = 30\n\n\ndef test_manage_courses_and_modules():\n    # Authenticate and get token\n    login_payload = {\n        \"email\": ADMIN_EMAIL,\n        \"senha\": ADMIN_PASSWORD\n    }\n    try:\n        login_response = requests.post(LOGIN_URL, json=login_payload, timeout=TIMEOUT)\n        assert login_response.status_code == 200, f\"Login failed with status code {login_response.status_code}\"\n        token = login_response.json().get(\"token\")\n        assert token, \"No token returned in login response\"\n    except requests.RequestException as e:\n        assert False, f\"Login request failed: {e}\"\n\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\"\n    }\n\n    # List existing courses\n    try:\n        list_response = requests.get(COURSES_URL, headers=headers, timeout=TIMEOUT)\n        assert list_response.status_code == 200, f\"Listing courses failed with status {list_response.status_code}\"\n        courses = list_response.json()\n        assert isinstance(courses, list), \"Courses listing is not a list\"\n    except requests.RequestException as e:\n        assert False, f\"List courses request failed: {e}\"\n\n    # Create a unique course\n    unique_course_name = f\"Test Course {uuid.uuid4()}\"\n    create_payload = {\"nome\": unique_course_name}\n    created_course_id = None\n\n    try:\n        create_response = requests.post(COURSES_URL, json=create_payload, headers=headers, timeout=TIMEOUT)\n        assert create_response.status_code == 201, f\"Create course failed with status {create_response.status_code}\"\n        created_course = create_response.json()\n        created_course_id = created_course.get(\"id\")\n        assert created_course_id, \"Created course ID not returned\"\n        assert created_course.get(\"nome\") == unique_course_name, \"Created course name mismatch\"\n\n        # Add a module to the created course\n        modules_url = f\"{COURSES_URL}/{created_course_id}/modulos\"\n        module_payload = {\"nome\": \"Introduction Module\"}\n        add_module_response = requests.post(modules_url, json=module_payload, headers=headers, timeout=TIMEOUT)\n        assert add_module_response.status_code == 201, f\"Add module failed with status {add_module_response.status_code}\"\n        added_module = add_module_response.json()\n        assert added_module.get(\"nome\") == module_payload[\"nome\"], \"Module name mismatch\"\n\n        # Verify the module appears when fetching course modules (assuming endpoint to get modules exists)\n        # If no direct modules GET endpoint provided in PRD, skip this part (no specific read endpoint mentioned)\n        # Could re-fetch course details if available, but PRD does not mention it.\n    except requests.RequestException as e:\n        assert False, f\"Create course or add module request failed: {e}\"\n    finally:\n        # Cleanup: delete the created course\n        if created_course_id:\n            try:\n                delete_url = f\"{COURSES_URL}/{created_course_id}\"\n                delete_response = requests.delete(delete_url, headers=headers, timeout=TIMEOUT)\n                # It might respond with 200 or 204 for successful delete\n                assert delete_response.status_code in (200, 204), f\"Failed to delete course, status {delete_response.status_code}\"\n            except requests.RequestException as e:\n                # Log error but do not fail test because test logic succeeded\n                print(f\"Cleanup delete course failed: {e}\")\n\n\ntest_manage_courses_and_modules()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 80, in <module>\n  File \"<string>\", line 48, in test_manage_courses_and_modules\nAssertionError: Create course failed with status 500\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-05T13:53:48.076Z",
    "modified": "2026-02-05T13:54:33.566Z"
  },
  {
    "projectId": "9c49b194-e156-4fdf-9508-b5d4b1b9511f",
    "testId": "e6da0f77-ff8c-4c06-8aed-440eef0a5863",
    "userId": "e408f458-7011-70d8-02e7-eee4728b30a5",
    "title": "TC010-manage extra non academic tasks",
    "description": "Test the extra tasks API endpoints for creating, listing, and marking tasks as completed to ensure accurate task management.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5001\"\nLOGIN_URL = f\"{BASE_URL}/api/auth/login\"\nTASKS_URL = f\"{BASE_URL}/api/tarefas-extras\"\nTIMEOUT = 30\n\nADMIN_EMAIL = \"admin@prismatech.com\"\nADMIN_PASSWORD = \"admin123\"\n\n\ndef test_manage_extra_non_academic_tasks():\n    # Login to get JWT token\n    login_payload = {\"email\": ADMIN_EMAIL, \"senha\": ADMIN_PASSWORD}\n    login_resp = requests.post(LOGIN_URL, json=login_payload, timeout=TIMEOUT)\n    assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n    token = login_resp.json().get(\"token\")\n    assert token, \"No token returned on login\"\n\n    headers = {\"Authorization\": f\"Bearer {token}\", \"Content-Type\": \"application/json\"}\n\n    # Create a unique extra task\n    task_payload = {\"titulo\": \"Test Extra Task\", \"descricao\": \"Task created during test_manage_extra_non_academic_tasks\"}\n    create_resp = requests.post(TASKS_URL, json=task_payload, headers=headers, timeout=TIMEOUT)\n    assert create_resp.status_code == 201, f\"Task creation failed: {create_resp.text}\"\n    task = create_resp.json()\n    task_id = task.get(\"id\")\n    assert task_id, \"Created task has no ID\"\n\n    try:\n        # List tasks and verify created task is returned\n        list_resp = requests.get(TASKS_URL, headers=headers, timeout=TIMEOUT)\n        assert list_resp.status_code == 200, f\"Failed to list tasks: {list_resp.text}\"\n        tasks = list_resp.json()\n        assert any(t.get(\"id\") == task_id for t in tasks), \"Created task not found in list\"\n\n        # Mark the created task as completed\n        complete_url = f\"{TASKS_URL}/{task_id}/concluir\"\n        complete_resp = requests.put(complete_url, headers=headers, timeout=TIMEOUT)\n        assert complete_resp.status_code == 200, f\"Failed to complete task: {complete_resp.text}\"\n\n        # Verify the task is marked completed (by re-listing and checking status)\n        verify_resp = requests.get(TASKS_URL, headers=headers, timeout=TIMEOUT)\n        assert verify_resp.status_code == 200, f\"Failed to list tasks after completion: {verify_resp.text}\"\n        tasks_after = verify_resp.json()\n        task_after = next((t for t in tasks_after if t.get(\"id\") == task_id), None)\n        assert task_after is not None, \"Task disappeared after marking completed\"\n        assert task_after.get(\"concluida\") is True or task_after.get(\"status\") == \"concluida\", \"Task not marked as completed properly\"\n\n    finally:\n        # Cleanup: Delete the created task to keep db clean\n        # No direct delete endpoint described, but if exists, attempt delete\n        delete_url = f\"{TASKS_URL}/{task_id}\"\n        requests.delete(delete_url, headers=headers, timeout=TIMEOUT)\n\n\ntest_manage_extra_non_academic_tasks()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 57, in <module>\n  File \"<string>\", line 25, in test_manage_extra_non_academic_tasks\nAssertionError: Task creation failed: {\"error\":\"Erro interno do servidor\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-05T13:53:48.083Z",
    "modified": "2026-02-05T13:54:38.719Z"
  }
]
